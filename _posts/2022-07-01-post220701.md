---
title: (Web) HTTPS, SSL 인증서
date: 2022-07-01 19:30 +0900
lastmod: 2022-07-01 19:30 +0900
categories: [Web]
tags: [Web]
mermaid: true
math: true
---
# 관련 용어

---

- **SSL(Secure Socket Layer)** 
    - SSL 프로토콜은 웹 서버와 브라우저 간 보안 통신규약 입니다. SSL 프로토콜이 제공하는 기능은 크게 아래와 같이 두 가지 입니다.
    - 인증 : 웹 서버의 진위성을 확인 합니다.
    - 데이터암호화 : 암호화 키를 가지고 송수신 되는 데이터를 암호화 합니다.
- **HTTPS(HTTP over Secure Socker Layer)**
    - SSL 프로토콜 위에서 돌아가는 HTTP 프로토콜을 HTTPS(HTTP over Secure Socker Layer)라고 합니다.
    - 데이터의 암호화를 제공하지 않는 HTTP와 달리 HTTPS는 데이터 암호화를 제공하므로 보안이 강화된 프로콜입니다.
- **SSL 인증서**
    - SSL 프로토콜은 Certificate Autority(CA)라 불리는 제 3자 기관에서 발급된 SSL 인증서를 통해 서버와 클라이언트의 인증 및 데이터 암호화를 수행 합니다. SSL 인증서에는 아래와 같이 두 가지 정보가 포함되어 있습니다.
        - 웹 서비스의 정보 : 인증서를 발급한 CA 정보, 서비스의 도메인 정보 등등
        - 서버 Public Key : 서버 Public Key 값 및 암호화 알고리즘
- **CA(Certificate Authority)**
    - SSL 인증서를 발급해주는 기관 입니다. 가장 대중적인 CA 기관으로는 Global Sign, GeoTrust, COMODO 등등 이 있습니다.
    - 보통 이러한 기관에서 SSL 인증서를 발급 받을 때는 일정 비용을 지불해야 합니다.
    - 따라서 테스트 또는 개발용 웹 서비스의 경우에는 OpenSSL을 이용하여 SSC (Self Signed Certificate)라는 사설 인증서를 사용합니다.
- **Public Key**
    - 데이터 암호화를 위해 사용되는 key 입니다. SSL 통신을 위해서는 서버와 클라이언트가 Public key를 사전에 교환하고, 데이터를 전송할 때마다, 상대방의 public key로 데이터를 암호화해 송신합니다.
    - *crt, *pem 등으로 발급된다.
- **Private Key**
    - 암호화되어 수신된 정보를 복호하기 위해 사용되는 key 입니다.
    - *.key, *-key.pem 등으로 발급된다.
- **CSR (Certificate Signing Request)**
    - SSL 인증서를 발급받기 위해 필요한 요구 사항들을 정의하는 파일입니다.
- **SSC (Self Signed Certificate)**
    - CA가 아닌 웹 서비스 소유자가 직접 생성한 인증서 입니다. SSC 인증서를 사용한 웹 서비스에 접근한 경우 웹 브라우저가 보안 경고를 띄우긴 하지만, 개발/테스트 용 웹 서비스에서 사용에는 무리가 없습니다. 따라서, 정식 서비스가 아닌 경우, CA를 통한 SSL 인증서 발급 비용을 절약하기 위해 많이 사용 됩니다.
- **SAN (Subject Alternative Name)**
    - 멀티도메인 인증서와 동일합니다. 하나의 인증서에 둘 이상의 도메인을 추가하여 사용하는 인증서 입니다.
- **SSL Hand Shake**
    
    ![Untitled](/assets/img/2022-07-01-web220701/Untitled.png)
    

# 암호화 방식

---

- **대칭키 방식**
    - 1개의 key 사용
    - 암호화하고 복호화 하는데 동일한 key를 사용
    - 단점: 서버와 브라우저가 동일한 key를 사용하므로, 외부에 노출되면 보안에 취약해진다.
- **공개키 방식**
    - 2개의 key 사용
    - 2개의 key를 만들어서 하나는 나(서버)만 갖고(비밀키:Private Key), 하나는 모두(브라우저)에게 나눠준다(공개키: Public Key)
    - '공개키'로 암호화한 건 '비밀키'로 복호화할 수 있고, '비밀키'로 암호화한 건 '공개키'로 복호화할 수 있다.
    - ex) 데이터 통신에 활용
        - 로그인: 브라우저에서 ID/PW를 공개키로 암호화해서 보내면, 서버는 비밀키로 복호화해서 로그인 처리한다.
    - ex) 인증에 활용
        - 전자서명: 서버가 비밀키로 암호화하여 보낸 데이터를, 브라우저가 공개키로 복호화할 수 있다면 서버가 비밀키의 주인임을 확인 수 있다.

# **HTTPS/SSL 기본 원리**

---

> **대칭키 방식과 공개키 방식을 혼용하여 서버의 신원을 보증하고, 데이터 통신을 암호화 한다.**
> 

1. 내 서버에서 '비밀키/공개키'를 생성한다.
2. 공인기관(CA)에서 내 서버의 SSL인증서를 발급 받는다.
    - SSL인증서는 'CA의 비밀키'로 암호화 되어 있다.
    - 인증서 내부에는 '내 서버의 공개키'가 저장되어 있다.
3. 내 서버에 인증서를 저장하고, SSL 통신을 설정해둔다.
4. 브라우저가 내 서버에 접속하면 인증서를 보내준다. 
5. 브라우저는 받은 인증서를 'CA의 공개키'로 복호화한다.
    - 인증서는 '발급한 CA의 비밀키'로 암호화 되어 있다.
    - 브라우저(크롬, 사파리 등)은 '공인된 CA들의 공개키'를 내부에 보관하고 있다.
6. 인증서 복호화에 성공한다면, 해당 인증서가 CA가 발급한 것임이 증명된다.
    - 인증서를 보낸 '내 서버'도 CA가 인증한 서버임이 증명된다.
7. 복호화한 인증서에서 '내 서버의 공개키'를 취득하여 데이터 통신에 활용한다.
    - 서버와 주고 받는 데이터 자체는 '대칭키 방식'으로 암호화 하고,
    - '대칭키 방식에 사용된 key'를 '내 서버의 공개키'로 암호화 한다.
    

# **HTTPS/SSL 상세 과정**

---

## 1. **SSL 인증서 생성**

---

- 내 서버의 비밀키/공개키 생성
- '서버 공개키'를 CA에 전달하면서 'SSL인증서' 발급 요청
- CA는 'CA 비밀키로 암호화된 인증서' 발급
    - **인증서 내용**
        - CA의 정보(발급자)
        - 서버의 정보(도메인, 서버 공개키 등)
        

## 2. **Handshake**

---

> **클라이언트와 서버가 통신을 하기 위해 서로를 파악하는 과정**
> 

- **클라이언트(브라우저)가 서버에 접속(Client Hello)**
    - 클라이언트에서 생성한 '랜덤 데이터' 서버로 전송
    - 클라이언트가 지원하는 '암호화 방식들' 서버로 전송
    - 세션 아이디(식별자) 전송 서버로 전송

- **서버가 클라이언트에 응답(Server Hello)**
    - 서버에서 생성한 '랜덤 데이터' 클라이언트로 전송
    - 서버가 선택한 '암호화 방식' 클라이언트로 전송 (서로 암호화 방식을 맞추는 작업)
    - ***'*인증서'** 클라이언트로 전송

- **클라이언트 확인**
    - 서버에게 받은 인증서 확인: 브라우저에 내장된 CA리스트에 있는 CA의 인증서인지 확인
    - 인증서 복호화: 브라우저에 내장된 해당 **CA의 공개키로 복호화**
        - 복호화 성공시, 인증서가 CA에 의해 발급된 것임이 증명
        - 인증서를 전송한 서버도 CA가 보증하는 서버임이 증명
    - 복호화된 인증서의 ***'*서버 공개키'** 획득

- **클라이언트의 'pre master secret key' 생성**
    - pre master secret 키 생성 : '서버에게 받은 랜덤 데이터' + '클라이언트 생성 랜덤 데이터' 조합하여 특정값 생성
    - pre master secret 키 암호화: 인증서에 있는 '서버 공개키'로 암호화
    - '암호화된 pre master secret 키' 서버로 전송

- **서버의 'session key'(대칭키의 key) 생성**
    - '암호화된 pre master secret 키'를 받아서 '서버 비밀키'로 복호화
    - '복호화된 pre master secret 키'를 이용해 master secret 값 생성하고,
    - 최종적으로 session key라는 걸 생성하여 클라이언트와 공유
    - 클라이언트-서버는 데이터를 주고 받을 때, session key를 통해 '대칭키 방식'으로 암호화하여 통신한다.

- **핸드쉐이크 종료**
    - 서버의 신원이 확인되었고,
    - 데이터 통신에 사용할 '대칭키 암호화 키값(session key)'도 공유하게 되었다.

## 3. **세션(전송)**

---

> **실제로 서버와 클라이언트가 데이터를 주고 받는 단계**
> 

- **클라이언트의 데이터 암호화/전송**
    - 'session key'를 통해 대칭키 방식으로 '데이터(ID/PW 등)를 암호화'하여 서버에 전송

- **서버의 데이터 복호화**
    - 'session key'를 통해 대칭키 방식으로 '데이터를 복호화' 하여 처리
    - 'session key'를 통해 대칭키 방식으로'응답 데이터(사용자 정보 등)를 암호화'하여 클라이언트에 전송

- **클라이언트의 데이터 복호화**
    - 'session key'를 통해 대칭키 방식으로 '데이터를 복호화' 하여 처리

## 4. **세션 종료**

---

1. **데이터 전송 종료**
2. **SSL 통신 종료**
3. **'session key' 폐기**
    - 매번 연결 시마다 새로운 session key를 생성하여 아주 짧은 시간만 사용하므로, 혹시 탈취되더라도 비교적 안전하다.
    

# 주체별 공개키/비밀키의 보유

---

- **CA(인증기관)**
    - CA의 비밀키 보유 → SSL인증서 암호화에 사용
- **SSL인증서**
    - 내 서버의 공개키 저장 → 클라이언트(브라우저)-서버 통신 데이터 암호화에 사용
- **클라이언트(브라우저)**
    - 다양한CA들의 공개키 보유 → SSL 인증서 복호화에 사용
- **내 서버**
    - 내 서버의 비밀키 보유 → 클라이언트(브라우저)-서버 통신 데이터 암호화에 사용