<!DOCTYPE html><html lang="en" data-mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="(Network)(Paper Review) MAC Protocol" /><meta property="og:locale" content="en" /><meta name="description" content="MAC Protocol" /><meta property="og:description" content="MAC Protocol" /><link rel="canonical" href="https://woobni.github.io/posts/post230701/" /><meta property="og:url" content="https://woobni.github.io/posts/post230701/" /><meta property="og:site_name" content="woobni’s diary." /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-07-01T19:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="(Network)(Paper Review) MAC Protocol" /> <script type="application/ld+json"> {"description":"MAC Protocol","url":"https://woobni.github.io/posts/post230701/","@type":"BlogPosting","headline":"(Network)(Paper Review) MAC Protocol","dateModified":"2023-12-05T13:06:01+09:00","datePublished":"2023-07-01T19:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://woobni.github.io/posts/post230701/"},"@context":"https://schema.org"}</script><title>(Network)(Paper Review) MAC Protocol | woobni's diary.</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="woobni's diary."><meta name="application-name" content="woobni's diary."><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/%EB%82%B4%EC%82%AC%EC%A7%84.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">woobni's diary.</a></div><div class="site-subtitle font-italic">Connecting the dots.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/woobni" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['woobni0357','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>(Network)(Paper Review) MAC Protocol</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>(Network)(Paper Review) MAC Protocol</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/woobni">woobni</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2023-07-01 19:00:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Sat, Jul 1, 2023, 7:00 PM +0900" >Jul 1, 2023</em> </span> <span> Updated <em class="timeago" date="2023-12-05 13:06:01 +0900 " data-toggle="tooltip" data-placement="bottom" title="Tue, Dec 5, 2023, 1:06 PM +0900" >Dec 5, 2023</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="11348 words"> <em>63 min</em> read</span></div></div></div><div class="post-content"><h1 id="mac-protocol">MAC Protocol</h1><blockquote><p>[ 응용 / 표현 / 세션 / 전송 / 네트워크 / <strong>데이터링크</strong> / 물리 ] OSI 7계층 데이터링크 계층의 MAC프로토콜에 대하여 정리</p></blockquote><h1 id="통신-protocol-이란">통신 Protocol 이란?</h1><hr /><ul><li>통신 프로토콜(Communication Protocol)은 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약</ul><h2 id="통신-프로토콜의-기본-요소">통신 프로토콜의 기본 요소 <a href="#통신-프로토콜의-기본-요소" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>구문(Syntax) : 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨등을 규정<li>의미(Semantics) : 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정<li>시간(Timing) : 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정</ul><h2 id="통신-프로토콜의-기능">통신 프로토콜의 기능 <a href="#통신-프로토콜의-기능" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><h3 id="단편화와-재결합"><strong>단편화와 재결합</strong> <a href="#단편화와-재결합" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>송신 측에서 전송할 데이터를 전송에 알맞은 일정 크기의 작은 블록으로 자르는 작업을 단편화(Fragmentation)이라 하고, 수신 측에서 단편화된 블록을 원래의 데이터로 모으는것을 재결합(Reassembly)이라고 합니다.</p><ul><li>단편화를 통해 세분화된 데이터 블록을 프로토콜 데이터 단위라고 합니다.<li>데이터를 단편화하여 전송하면 전송 시간이 빠르고, 통신중의 오류를 효과적으로 제어할 수 있습니다.<li>너무 작은 블록으로 단편화할 경우 재결합 시 처리 시간이 길어지고, 데이터외에 부수적인 데이터가 많아지므로 비효율적입니다.</ul><h3 id="캡슐화"><strong>캡슐화</strong> <a href="#캡슐화" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>캡슐화(Encapsulation)는 단편화된 데이터에 송, 수신지 주소, 오류 검출 코드, 프로토콜 기능을 구현하기 위한 프로토콜 제어 정보 등의 정보를 부가하는 것으로 요약화라고도 합니다.</p><ul><li>대표적인 예가 데이터 링크 제어 프로토콜의 HDLC(High-Level Data Link Control) 프레임입니다.<ul><li>HDLC 프레임은 기본적으로 Flag, 주소 및 제어, 정보 및 CRC(Cyclic Redundancy Check) 세 가지 부분으로 구성됨. 각 부분은 데이터 링크 프레임을 시작하고 종료하며, 제어 및 오류 확인에 필요한 정보를 제공<li>프로토콜의 확장인 PPP(Point-to-Point Protocol)과 HDLC 기반의 LAPB(Link Access Procedure, Balanced) 등이 사용</ul><li>정보 데이터를 오류 없이 정확하게 전송하기 위해 캡슐화를 수행합니다.</ul><h3 id="흐름제어"><strong>흐름제어</strong> <a href="#흐름제어" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>흐름제어(Flow Control)는 수신 측의 처리 능력에 따라 송신 측에서 송신하는 데이터의 전송량이나 전송 속도를 조절하는 기능입니다. 정지-대기방식, 슬라이딩 윈도우 방식을 이용합니다.</p><h3 id="오류제어"><strong>오류제어</strong> <a href="#오류제어" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>오류제어(error Control)는 전송중에 발생하는 오류를 검출하고 정정하여 데이터나 제어 정보의 파손에 대비하는 기능입니다.</p><h3 id="동기화"><strong>동기화</strong> <a href="#동기화" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>동기화(Synchroniztion)는 송, 수신 측이 같은 상태를 유지하도록 타이밍(Timing)을 맞추는 기능입니다.</p><h3 id="순서제어"><strong>순서제어</strong> <a href="#순서제어" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>순서제어(sequencing)는 전송되는 데이터 블록(PDU)에 전송 순서를 부여하는 기능으로, 연결 위주의 데이터 전송 방식에만 사용됩니다. 송신 데이터들이 순서적으로 전송되도록 함으로써 흐름 제어 및 오류 제어를 용이하게 하는 기능을 합니다.</p><h3 id="주소지정"><strong>주소지정</strong> <a href="#주소지정" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>주소지정(Addressing)은 데이터가 목적지까지 정확하게 전송될 수 있도록 목적지 이름, 주소, 경로를 부여하는 기능입니다. 목적지 이름은 전송할 데이터가 가리키는곳, 주소는 목적지의 위치, 경로는 목적지에 도착할 수 있는 방법을 의미합니다.</p><h3 id="다중화"><strong>다중화</strong> <a href="#다중화" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>다중화(Multiplexing)는 한개의 통신 회선을 여러 가입자들이 동시에 사용하도록 하는 기능입니다.</p><h3 id="경로제어"><strong>경로제어</strong> <a href="#경로제어" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>경로제어(Routing)는 송, 수신 측 간의 송신 경로 중에서 최적의 패킷 교환 경로를 설정하는 기능입니다.</p><h3 id="전송-서비스"><strong>전송 서비스</strong> <a href="#전송-서비스" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>전송하려는 데이터가 사용하도록 하는 별도의 부가 서비스입니다.</p><ul><li>우선순위 (Priority): 특정 메시지를 최대한 빠른 시간 안에 목적지로 전송하기 위하여 메시지 단위에 우선순위를 부여하여 우선순위가 높은 메시지가 먼저 도착하도록 합니다. 예를 들어, 음성 통화나 비디오 스트리밍과 같이 실시간으로 처리되어야 할 데이터는 우선순위를 높게 설정하여 최소한의 지연으로 전송되도록 합니다. 반면에 이메일과 같은 일반적인 데이터는 상대적으로 낮은 우선순위를 가지게 됩니다.<li>서비스 등급 (Quality of Service - QoS): 데이터의 요구에 따라 서비스 등급을 부여하여 서비스합니다. 한정된 대역폭을 효율적으로 분배하고 데이터의 중요성에 따라 우선순위를 조절함으로써, 더 중요한 서비스가 더 나은 성능을 유지합니다.<li>보안성 (Security): 액세스 제한과 같은 보안체제를 구현합니다.</ul><h1 id="매체-접근-제어-medium-access-control-mac-이란">매체 접근 제어 (Medium Access Control, MAC) 이란?</h1><hr /><ul><li>데이터링크 계층은 물리계층의 문제여부를 판단하여 신뢰성을 확보하며, 데이터링크 계층에는 다음 2개의 부계층(서브레이어)로 구분된다<ul><li><strong>LLC (Logical Link Control)</strong><li><strong>MAC (Medium Access Control)</strong><li>LLC에서 MAC을 거쳐 물리계층으로 전달되는 구조 (LLC 또는 MAC으로 전송되는게 아니고 둘다 거친다)</ul><li>MAC 주소: MAC 부계층 상에서, 노드 또는 장치의 식별을 위해, 48 비트(6 바이트) 크기를 갖는, 하드웨어 상에 구현된 물리적 주소<li><strong>여기서 매체(Medium)은 데이터를 전송하는 데 사용되는 물리적인 통신 매체를 의미. 이 매체는 데이터가 전송되는 물리적인 환경을 나타냄.</strong><ul><li>예를 들어, 유선 통신에서는 동축 케이블, 광섬유 케이블, 트위스트 페어 케이블 등이 매체에 해당. 이러한 유선 매체는 전기적인 신호를 사용하여 데이터를 전송<li>무선 통신에서는 라디오 또는 마이크로파를 사용하여 데이터를 전송. 무선 매체는 전파를 이용하여 데이터를 공기를 통해 전송하는 방식으로, 더 넓은 범위에서 통신이 가능하며, 유선 제약이 없음</ul><li><strong>MAC(Medium Access Control)은 여러 단말들 간에 공유 매체(Shared Medium)의 동시 사용에 대한 단말 간 충돌(경합) 발생을 제어(경감)하는 방식을 총칭</strong><ul><li><p>예를 들어, 이더넷에서는 CSMA/CD(Carrier Sense Multiple Access with Collision Detection)라는 매체 접근 제어 방식이 사용되며, 무선 네트워크에서는 CSMA/CA(Carrier Sense Multiple Access with Collision Avoidance) 방식이 사용</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled.png" alt="Untitled" data-proofer-ignore></p></ul><li>매체 자원 관점의 보다 일반화된 기술 용어로는, Multiple Access (다원접속)가 있음<ul><li><p>한정된 전송 자원을 다수의 노드들이 효율적으로 공평하게 공유 (통신 자원의 공유</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%201.png" alt="Untitled" data-proofer-ignore></p></ul></ul><h1 id="mac-protocol-1">MAC Protocol</h1><hr /><ul><li><strong>MAC(Medium Access Control) 프로토콜은 네트워크에서 여러 개의 노드가 공유 매체(예: 이더넷, 무선 채널 등)에 접근하는 방법을 규정하는 프로토콜</strong><li>유선 LAN: CSMA/CD → 802.3, Token Bus → 802.4, Token Ring → 802.5<li><p>무선 LAN: CSMA/CA → 802.11</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%202.png" alt="Untitled" data-proofer-ignore></p></ul><h2 id="csma">CSMA <a href="#csma" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>기지국이 매체를 사용하려고 시도하기 이전에 매체를 감지하게 되면 충돌의 기회를 줄일 수 있다. CSMA(반송파 감지 다중 접근)는 각 지국이 전송하기 이전에 먼저 매체에 귀를 기울일 것(또는 매체의 상태를 확인)을 요구하고 있다. 다시 말해 CSMA는 <strong>Listen before Talk (LBT) 원칙</strong>에 기반을 두고 있다.<li><strong>각 노드들이 프레임을 전송하려고 공유 매체(반송파)에 접근하기 전에, 먼저 매체가 사용중인지 확인(Carrier Sensing)하며 다중접속(Multiple Access)하는 방식</strong><li>CSMA의 한계<ul><li>CSMA는 충돌의 가능성을 줄일 수 있으나 완전히 없앨 수는 없다. 기지국이 매체를 감지하여 매체가 idle한 것을 감지한다 해도 다른 지국이 전송한 프레임의 첫 번째 비트가 아직 도달 중일 수 있다. 프레임이 전송(전파)되는 시간차 때문에 idle한 것을 감지하고 나서 프레임을 전송하는 경우 다른곳에서 보낸 프레임이 도착하여 두 프레임이 충돌, 손상될 수 있다. 전파 지연(Propagation Delay) 때문</ul></ul><h2 id="ieee-8023---csmacd-carrier-sense-multiple-accesscollision-detection-반송파-감지-다중-액세스충돌-검출">IEEE 802.3 - CSMA/CD (Carrier Sense Multiple Access/Collision Detection) 반송파 감지 다중 액세스/충돌 검출 <a href="#ieee-8023---csmacd-carrier-sense-multiple-accesscollision-detection-반송파-감지-다중-액세스충돌-검출" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>유선랜 중 반이중 방식의 이더넷에서 각 단말이 신호 전송을 위해 전송 공유매체에 규칙있게 접근하기 위한 MAC 방식<li>동일한 전송로(버스)를 여러 단말기가 공유하도록 전송매체에 대한 다중접근 기능이 필요한데 그에 사용 되는 방식 중 가장 많은게 CSMA/CD<li>CSMA/CD<ol><li>어느 A, B 컴퓨터가 다른 컴퓨터로 스위치를 통해 서버로 정보를 요청한다 가정<li>A, B 컴퓨터는 서버에 정보를 전송하기 위해 회선이 사용 중이지 않는지 확인. (반송파 감지 - Carrier Sense, 또는 청취)<li>양 컴퓨터는 회선이 사용 중이지 않다는 것을 확인하고 두 컴퓨터가 서버로 정보를 요청한다 (다중 접근 - Multi Access)<li>두 컴퓨터의 통신이 충돌(Collision), 신호가 퍼져나갈 때 비정상적인 증폭으로 충돌을 확인한다. (충돌 감지 - Collision Detection)<li>충돌을 확인한 전송장비가 충돌을 알린다. (충돌 신호 - Jam Signal)<li>A, B 컴퓨터는 충돌을 확인 후 백오프(Backoff) 알고리즘을 수행하고, 임의의 시간동안 전송을 중단한다.<li>임의의 시간이 지난 후, 다시 청취모드로 돌아가 이 과정을 충돌이 일어나지 않을 때까지 반복한다.</ol><li>네트워크 허브라는 것이 등장하여 네트워크의 형태가 버스형에서 스타형으로 변경되고, 허브가 업그레이드가 되어 ‘스위칭 허브’ 또는 ‘L2 스위치’로 변경됨에 따라, 이더넷은 실질적으로 충돌 자체가 발생하지 않는 구조로 바뀌었다. 현재의 이더넷은 충돌이 발생하지 않는 구조이지만, 과거와의 호환성 문제로 CSMA/CD는 여전히 이더넷 표준에 포함되어 있다.</ul><h2 id="ieee-80211---csmaca-carrier-sense-multiple-accesscollision-avoidance-반송파-감지-다중-액세스충돌-무시">IEEE 802.11 - CSMA/CA (Carrier Sense Multiple Access/Collision Avoidance) 반송파 감지 다중 액세스/충돌 무시 <a href="#ieee-80211---csmaca-carrier-sense-multiple-accesscollision-avoidance-반송파-감지-다중-액세스충돌-무시" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>Wi-Fi가 이 IEEE 802.11 표준에 속한다. 위에는 유선랜, 여기는 무선랜<li>전파 신호는 감쇠가 크므로 여러개의 충돌되는 신호 에너지도 그렇게 높지 않아 유선 LAN 처럼 전송매체에서의 에너지 레벨 변화로는 매체 사용 감지 판단을 할 수 없음. 따라서 감지하지 않고 회피하는 방식을 사용<ul><li>참고) 유선 LAN (Ethernet)<ul><li>유선매체 전압의 변화에 의해 현재 매체 점유 및 충돌 검출을 쉽게 알 수 있음<li>Carrier Sensing Threshold - LAN 카드 자신 보다 높은 전압이 감지되는지 여부로 판단하거나, 또는 맨체스터 코딩 방식에서의 전압 변화폭 등으로 판단</ul></ul><li>IEEE 802.11 표준을 보면 두가지 매체 접근 방식이 있음<ul><li>하나는 PCF(Point Coordination Function) Mode라고 하고 우선 순위 기반으로 경쟁하는 방식이다.<li>기본적으로 사용하는 방식은 DCF(Distributed Coordination Function) Mode로, CSMA/CA 프로토콜을 사용하는 동등한 우선순위를 가지고 경쟁하는 방식이다.</ul><li>CSMA/CA (CSMA개념은 위랑 동일. CSMA/CD 에서는 ACK 프레임을 사용하지 않지만, CSMA/CA 에서는 ACK 프레임을 사용한다.)<ol><li>프레임을 전송하고자 하는 Station은 매체가 idle인 상태가 될 때까지 기다린다.<li>만약 idle 상태가 된다면 원거리의 다른 Station이 매체를 이미 사용하고 있을 수도 있기 때문에 IFS(Inter frame space)라고 부르는 시간동안 대기한다.<li>IFS동안 대기한 뒤에도 idle 상태라면 Contention Window에서 랜덤한 Slot time을 갖고 대기한다.<li>Slot time만큼 대기한 뒤에도 idle 상태라면 전송한 뒤 수신자로부터 ACK 메세지가 오길 기다린다. 이 때, 기다리면서 타이머를 돌리는데 타이머가 끝날 때 까지 ACK 메세지가 자신에게 오지 않으면 다시 뒤로 돌아가서 재전송을 시도한다.<li><p>ACK 메시지가 도착하면 전송이 성공적으로 이루어졌다고 생각하고 종료한다.</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%203.png" alt="Untitled" data-proofer-ignore></p></ol></ul><h3 id="ifs-inter-frame-space">IFS (Inter Frame Space) <a href="#ifs-inter-frame-space" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>충돌 회피 방법 요소<li>IFS (Inter Frame Space)는 프레임 간 공간을 이용한 하나의 충돌 회피 방법으로 한 프레임의 전송이 끝난 후 다음 프레임을 전송하기 전에 기다리는 시간을 의미<li>우성 채널이 휴지 상태인 것으로 확인 되더라도 전송을 늦추어서 충돌을 회피한다. 휴지 상태의 채널이 발견된 즉시 전송하지 않는 것이다. 기지국은 IFS라 불리는 일정 시간을 기다린다. 채널을 감지 했을 때 휴지 상태인 것처럼 보일지라도 멀리 떨어진 지국이 이미 전송을 시작 했을지 모르기 때문이다. 이런 경우 기다리지 않고 전송을 해버리면 충돌이 일어날 수 있으므로 IFS동안 기다리게 된다.<li>CSMA/CA에서 IFS는 기지국이나 프레임의 우선순위를 규정하는 것에도 사용될 수 있다. 예를 들어 더 짧은 IFS시간을 갖도록 허락된 기지국은 다른 기지국에 비해 높은 우선순위를 갖는 셈이다.<li>동기화된 MAC 프로토콜에서의 IFS<ul><li>각 장치들이 데이터 전송을 위해 정해진 프레임 구조와 타이밍을 따르는 프로토콜. 이러한 프로토콜에서는 각 장치들이 데이터를 주고받을 때 일정한 프레임 간격과 IFS를 준수하여 동작</ul><li>송신측 DIFS(Distributed IFS), 수신측 SIFS(Short IFS)</ul><h3 id="contention-window">Contention Window <a href="#contention-window" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>충돌 회피 방법 요소<li>초기 백오프 (Initial Backoff): 공유 매체가 사용가능함을 알고난 후에도 일정시간(IFS)을 기다리고 그때부터 임의 대기하게 되는 슬롯 단위로 구분되는 시간 범위<li>역방향 백오프 (Backoff After Collision): CSMA 방식은 충돌이 발생하면 잠시 전송을 멈추는 Back off 상태가 되는데 contention window 구간만큼 대기 후 다시 전송<li>contention window는 { 0, 1, 2, 3, … , 2^n-1} 만큼의 크기를 가지며, 이 contention window가 커질수록 충돌 할 확률이 낮아진다. 경합 창은 초기 크기로 시작하고, 충돌이 발생할 때마다 두 배로 증가하는 것이 일반적임. 이렇게 함으로써 초기에는 경합이 낮아지고 노드들 사이의 충돌 가능성이 줄어듬<li><p>무작위 시간만큼 대기하는 무작위의 스펙트럼이 contention window. <strong>방법이라기보다는 충돌 시 대기할 시간의 스펙트럼이라고 기억하면 될 것 같다.</strong></p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%204.png" alt="Untitled" data-proofer-ignore></p></ul><h3 id="clear-channel-assessment-cca">Clear Channel Assessment (CCA) <a href="#clear-channel-assessment-cca" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>무선 LAN 802.11 물리 계층(PHY) 상의 기능 중의 하나<ul><li>공유 무선채널에 대해 물리적으로 사용 가능 여부(busy 또는 idle)에 대한 감지 기능<ul><li>물리 계층은 CCA를 통해 알아낸 채널상태를 무선 LAN MAC 부계층에 알려주어야 함<li>참고) 논리적으로(물리적인 신호나 데이터 전송 상태를 이해하고 해석하여) 채널 사용중(busy) 여부를 감지하는 방법 → NAV</ul></ul><li>ED(Energy Detect)/CCA: RSSI 값이 임계 레벨(단위:dBm)을 넘는지 여부로 busy 판단하여 상위계층에게 보고<li>CS(Carrier Sense)/CCA: 수신기에서 고정 속도(DSSS PLCP 1 Mbps, DSSS Short Preamble 2 Mbps, OFDM 6 Mbps)로 잡아내는 PLCP 프리엠블 및 PLCP 헤더내의 길이 필드를 살펴보고, 현재의 프레임의 지속시간을 계산하여 busy 예상시간을 상위계층에게 보고함</ul><h3 id="유선무선-mac-프레임의-일반-포멧-차이">유선/무선 MAC 프레임의 일반 포멧 차이 <a href="#유선무선-mac-프레임의-일반-포멧-차이" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>유선 LAN은 대부분 동일 유형의 프레임으로 전달되지만, 무선 LAN은 많은 유형의 프레임들이 저마다 다른 형태와 역할을 갖고 전달됨<li><p>유선 LAN : IEEE 802.3 (CSMA/CD) MAC 부계층의 프레임 포멧</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%205.png" alt="Untitled" data-proofer-ignore></p><li><p>무선 LAN : IEEE 802.11 MAC 부계층의 일반적인 프레임 포멧</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%206.png" alt="Untitled" data-proofer-ignore></p></ul><h3 id="무선-mac-프레임의-유형-구분">무선 MAC 프레임의 유형 구분 <a href="#무선-mac-프레임의-유형-구분" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>802.11 표준은 MAC 프레임 형태를 역할에 따라 크게 3가지로 구분<ul><li>802.11 데이터프레임 (유형 type : 10): 주로, 실제 정보 데이터를 실어나르는 역할<li>802.11 제어프레임 (유형 type : 01): 데이터의 올바른 전달을 위한 채널 획득, 반송파 감지, 데이터 수신 긍정 확인 응답 등<li>802.11 관리프레임 (유형 type : 00): 무선망 및 무선 노드에 대한 스캔, 결합, 인증, 해제 등</ul></ul><h3 id="80211-mac-프레임의-일반적인-포멧">802.11 MAC 프레임의 일반적인 포멧 <a href="#80211-mac-프레임의-일반적인-포멧" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%207.png" alt="Untitled" data-proofer-ignore></p><h2 id="mac-protocol-성능-척도-measure">MAC Protocol 성능 척도 (measure) <a href="#mac-protocol-성능-척도-measure" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ol><li>Energy consumption<li>Delay<li>Throughput</ol><h1 id="ieee802154-wsn">IEEE802.15.4 (WSN)</h1><hr /><ul><li>IEEE 802.11 무선 LAN 기술이 저속의 전송속도와 소비전력 측면에서 문제점이 대두되고 있고 IEEE 802.15.1의 블루투스는 복잡도가 나날이 증가함에 따라 가격 및 배터리에 문제점이 노출되고 있다. 이러한 단점을 극복하기 위해 IEEE 802.15.4는 무선 통합 리모컨, 가전기기 컨트롤러, 빌딩 제어 등에 사용하기 위한 저속, 저가격, 저소비전력의 무선 전송 기술 표준을 제정<li>물리 계층(PHY)과 미디어 액세스 콘트롤 계층(MAC)을 정의하는 표준으로서, 저속도 무선 개인 통신망(Low Rate Wireless Personal Area Networks, LR-WPANs)를 위한 표준 가운데 하나이다. 대표적 이름은 지그비 Zigbee이다.<li>주로 2.4GHz, 915MHz, 868MHz 등의 무선 주파수 대역을 사용. 2.4GHz 주파수 대역은 Wi-Fi와 블루투스와 공유되며, 주파수 대역의 선택은 지역 규제에 따라 달라질 수 있음<ul><li>868.0 ~868.6 MHz : 유럽<li>902~928 MHz : 북미<li>2400~2483.5 MHz : 세계</ul><li>IEEE 802.15.4는 16비트 주소 체계를 사용. 따라서 네트워크 내에서 최대 65,535개의 디바이스를 구별<li><p>CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance) 방식을 사용하여 효율적인 채널 접근을 지원</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%208.png" alt="Untitled" data-proofer-ignore></p></ul><h1 id="duty-cycling-in-wsns">D<strong>uty cycling in WSNs</strong></h1><hr /><ul><li>무선 센서 네트워크에서 노드들이 네트워크에서 깨어나고 수면하는 동안 고속 데이터 전송, 낮은 지연, 에너지 효율성을 어떻게 달성할 수 있는지가 도전 과제<li><strong>에너지 제약이 있는 WSNs에서 저전력 동작(Energy consumption)을 위한 핵심 메커니즘 중 하나는 duty cycling. 이 방식에서 각 센서 노드는 주기적으로 활성 상태와 수면 상태를 번갈아 가며 동작</strong><ul><li>참고) CSMA 메커니즘은 Throughput과 관련<li>Duty cycling MAC Protocol은 Delay랑 Throughput을 개선시키는 쪽으로 연구가 진행되어야 할 것</ul><li>Duty cycling의 주요 매개변수로는 수면 시간, 활성 시간, 그리고 활성 상태와 수면 상태에서의 에너지 소비량이 포함됨. Duty cycle의 주기는 수면 시간과 활성 시간의 합<li>Duty cycling 무선 센서 노드를 대상으로 개발된 표준 MAC 프로토콜은 동기화된 접근과 비동기화된 접근, 그리고 이 두 가지 방식의 하이브리드 조합으로 나뉨. 이러한 방식들은 idle listening을 줄이는 것을 목표로 하며, idle listening은 노드가 패킷을 받지 않는 상태에서도 매체를 청취하는 시간을 의미(802.11 프로토콜에서는 idle listening이 상당한 에너지를 소비한다는 것이 확인되었기 때문)</ul><h1 id="duty-cycling-mac-protocol">Duty cycling MAC Protocol</h1><hr /><ul><li>Duty cycling MAC Protocol 은 두 가지 범주로 나뉨<ol><li>노드의 깨어있는 시간이 동시에 발생하도록 보장하기 위해 동기화 방법을 사용<li>동기화 요구사항이 없으며 대신 확장된 preamble과 저전력 수신(low power listening)에 의존하는 방법</ol></ul><h2 id="동기화된-프로토콜">동기화된 프로토콜 <a href="#동기화된-프로토콜" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>S-MAC, T-MAC<li>프레임 내에서 노드가 활성 상태와 수면 상태인 시간을 협상하는 방식으로 동작. 노드들이 통신을 위해 깨어나야 하는 시간을 지정함으로써 idle listening에서 발생하는 시간과 에너지를 줄임(데이터를 전송하기 전에 미리 정해진 타이밍 또는 클럭 신호에 맞추어 데이터를 전송하는 방식)<li>동기식 기술은 동기화를 위한 오버헤드가 발생하므로 비동기식 기술에 비해 단점이 될 수 있음</ul><h2 id="비동기화된-프로토콜">비동기화된 프로토콜 <a href="#비동기화된-프로토콜" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>B-MAC, X-MAC<li>low power listening (LPL) 또는 preamble sampling을 활용하여 데이터를 전송하는 발신자와 동작 중인 수면 상태인 수신자를 연결. 노드들 사이에서 명시적인 동기화 없이도 저전력 통신이 가능하며, idle listening을 제한할 수 있음.<li>장점<ul><li>비동기화된 low power listening 프로토콜의 주요 장점은 발신자와 수신자가 완전히 분리된 상태에서 duty cycle을 수행할 수 있다는 점. 동기화된 깨어짐/수면 스케줄링에 필요한 노드간 동기화와 관련된 오버헤드를 제거할 수 있음</ul><li>단점<ul><li>low power listening의 긴 프리앰블은 몇 가지 단점을 가짐. 발신자와 수신자 모두 에너지 소비 면에서 최적이 아니며, 비목표 수신자들이 과도한 에너지 소비를 일으키는 overhearing 문제와 각 호프마다의 초과 지연 문제가 발생<ul><li>overhearing (more)<ul><li>예를 들어, A, B, C라는 세 개의 노드가 같은 무선 채널을 사용하여 통신하고 있다고 가정해봅시다. 이 때, A 노드가 데이터를 B 노드에게 전송하려고 할 때, C 노드가 현재 채널을 사용하여 B 노드와 통신하고 있을 수 있습니다. A 노드는 C 노드의 통신을 무작위로 감지하게 되는데, 실제로는 A 노드가 C 노드의 데이터를 필요로 하지 않더라도 이러한 감지가 발생할 수 있습니다.<li>이런 오버허어링은 무선 네트워크에서 성능 저하와 자원 낭비를 초래할 수 있습니다. 왜냐하면 오버허어링으로 인해 통신이 중단되거나 지연될 수 있기 때문입니다. 오버허어링을 관리하고 최소화하기 위해 무선 네트워크에서는 앞서 언급한 CSMA/CA와 같은 프로토콜이 사용됩니다. 이러한 프로토콜은 노드가 채널의 사용 상태를 모니터링하고, 채널이 사용 가능한 경우에만 통신을 시작하도록 지시하여 오버허어링을 감소시키고 전송 충돌을 방지하는 역할을 합니다.</ul></ul><li>목표 수신자는 데이터 패킷을 수신하기 위해 프리앰블이 끝날 때까지 기다려야 하므로 수신자와 송신자 모두 에너지가 낭비. 또한, low power listening 접근 방식은 더 먼 거리의 노드에게 불필요하게 에너지를 소비하게 만들어, 수신자들 사이의 초과 에너지 소비를 야기. 수신자가 데이터 패킷을 받기 위해 프리앰블이 끝날 때까지 기다려야 하는 점은 각 호프에서의 지연 시간을 최소한 프리앰블의 길이로 제한하는데 이어지며, 멀티호프 경로에서 이러한 지연이 쌓이면서 실질적인 지연이 크게 증가</ul><li>하이브리드 프로토콜<ul><li>T-MAC과 같은 동기화된 프로토콜과 비동기화된 low power listening의 조합으로 이루어짐</ul></ul><h2 id="비교">비교 <a href="#비교" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>에너지 소비, 지연 시간 및 처리량 측면에서 비동기적인 듀티 사이클링 기술이 동기화된 기술보다 선호되는 경우가 많습니다. 이는 동기화로 인한 오버헤드가 없기 때문이기도 합니다.<li>또한 비동기적인 기술은 스케줄 정보를 공유할 필요가 없으며, 데이터를 수신하거나 전송하는 경우를 제외하고는 매체를 샘플링하기 위해 충분히 오래 깨어 있지 않아도 됩니다. 따라서 깨어 있는 기간은 동기화된 방법보다 훨씬 짧을 수 있습니다.<li>깨어 있는 기간이 짧으면서도 낮은 듀티 사이클을 유지할 수 있기 때문에 비동기적인 프로토콜은 더 자주 깨어나서 작동할 수 있으며, 이로 인해 지연 시간이 감소하고 처리량이 증가할 수 있습니다.<li>그러나 프리앰블이 너무 길 경우, 패킷 당 에너지 소비가 증가하고 지연 시간이 늘어날 수 있음<ul><li>상세 설명 (more)<ol><li>프리앰블이 길어지면 데이터를 전송하기 위해 더 많은 시간이 필요하게 됩니다. 이는 통신 지연을 증가시키며, 실시간 통신이 요구되는 애플리케이션에서는 부적합할 수 있습니다. 예를 들어 음성 통화나 동영상 스트리밍과 같은 응용 프로그램에서는 짧은 지연 시간이 중요합니다.<li>비동기적 듀티 사이클링 기술은 수신기를 주기적으로 깨우고 수면 상태로 전환하여 에너지를 절약하는 방법입니다. 그러나 프리앰블이 길어지면 수신기가 데이터를 수신하기 위해 더 오래 깨어 있어야 합니다. 이는 전력 소모를 증가시키며, 저전력 통신 시스템의 핵심 목표인 에너지 절약에 부정적인 영향을 미칠 수 있습니다.</ol></ul><li>일반적으로, 지연 요구 사항이 여유로운 응용 분야의 경우, 동기화된 접근 방식이 더 적절할 수 있습니다.</ul><h2 id="s-mac-sensor-mac">S-MAC (<strong>**Sensor MAC</strong>**) <a href="#s-mac-sensor-mac" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li><strong>이 프로토콜은 주기적인 수면, 가상 클러스터링, 그리고 적응적 수신(adaptive listening)이라는 세 가지 기술을 사용하여 저전력 duty-cycling을 달성</strong><li>기존 많은 WSN에서는 센싱 이벤트가 발생하지 않을 경우 노드가 오랫동안 대기 상태(idle)에 있음. 이 기간 동안 데이터 전송률이 매우 낮기 때문에 노드를 항상 수신 대기 상태로 유지할 필요가 없음. 우리의 프로토콜은 주기적인 수면 모드로 노드가 들어가도록하여 수신 시간을 줄임<li><p>S-MAC에서 노드들은 주기적으로 깨어나서 데이터를 수신하고 송신한 뒤 다시 수면 상태로 돌아감. 깨어나는 기간의 시작부분에서, 노드는 이웃 노드들과 동기화와 스케줄 정보를 교환하여(브로드캐스트) 노드와 이웃 노드들이 동시에 깨어나도록 보장. 이를 통해 idle listening이 감소하고, RTS와 CTS를 통해 충돌 및 오버히어링을 피함</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%209.png" alt="Untitled" data-proofer-ignore></p><ul><li>첫 번째 부분은 SYNC 패킷을 수신하는 데 사용되며, 두 번째 부분은 RTS 패킷을 수신하기 위해 사용. 각 부분은 발신자가 캐리어 감지를 수행할 수 있는 여러 시간 슬롯으로 나누어짐</ul><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%2010.png" alt="Untitled" data-proofer-ignore></p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%2011.png" alt="Untitled" data-proofer-ignore></p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%2012.png" alt="Untitled" data-proofer-ignore></p><li>동일한 수면 스케줄을 갖는 노드들을 가상의 클러스터로 형성. 이 스케줄은 로컬적으로만 적용되며, 시스템 전체의 동기화를 필요로하지 않는 가상 클러스터를 형성. 두 개의 가상 클러스터 경계에 있는 노드들은 두 클러스터의 스케줄을 모두 따르며, 이로써 네트워크 전체적인 연결성을 유지<ul><li><p>각 노드가 주기적인 listen 및 sleep을 시작하기 전에, 해당 노드는 일정을 선택하고 이를 이웃 노드와 교환. 각 노드는 모든 알려진 이웃의 일정을 저장하는 일정 테이블을 유지</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%2013.png" alt="Untitled" data-proofer-ignore></p></ul><li><p>contention-based scheme</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%2014.png" alt="Untitled" data-proofer-ignore></p><ol><li>노드는 브로드캐스트를 통해 근처의 이웃 노드들과 스케줄을 교환<li>A가 B랑 통신하기를 원한다면, B가 들을 때까지 기다려야 함<li>여러 노드가 어떤 노드랑 통신하기를 원한다면 그 노드가 들을 때까지 매체에 대해 경쟁해야 함(contention 메커니즘은 RTS-CTS를 사용하는 802.11과 동일)<ul><li><strong>RTS-CTS (more)</strong><ul><li>RTS/CTS(Request to Send / Clear to Send)는 802.11 무선 네트워크 프로토콜에서 선택적으로 사용할 수 있는 통신 매커니즘이다. RTS/CTS는 은닉 노드 문제 (hidden terminal problem)로 알려진 프레임 충돌을 막기 위해 사용한다.<li>데이터 전송을 원하는 노드가 무선 링크를 듣고 있는 모든 노드에게 송신 요청(Request To Send) 프레임을 보내는 것으로 프로세스가 시작된다. 송수신 중인 다른 신호가 없어 전송이 가능한 무선 환경인 경우, 목적지 노드는 이 신호에 대해서 무선 링크를 듣고 있는 모든 노드에게 송신 확인(Clear To Send) 프레임을 보내 응답하게 된다. RTS나 CTS 프레임을 받은 다른 모든 노드는 정해진 시간 동안 데이터 전송을 제한하게 된다. (은닉 노드 문제가 해결됨). 전송을 제한하게 되는 시간은 RTS와 CTS 프레임 안에 적혀있다.<li><p>RTS/CTS는 Carrier sense multiple access with collision avoidance (CSMA/CA) 논리적 신호 탐지(virtual carrier sensing) 을 구현하기 위한 추가적이고 선택적인 방법이다.</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%2015.png" alt="Untitled" data-proofer-ignore></p></ul></ul><li>첫 번째 RTS 패킷을 보내는 노드가 매체를 점유하며, 수신자는 CTS 패킷으로 응답</ol><li>메시지 패싱<ul><li>긴 메시지를 하나의 패킷으로 전송하는 것의 단점은, 첫 번째 전송에서 몇 비트만 손상되었을 경우에도 긴 패킷을 다시 전송하는 데 드는 높은 재전송 비용. SMAC에서는 긴 데이터 메시지가 분할되어 송신자에서 수신자로 전송됩니다. 수신자는 모든 프래그먼트에 대해 확인 응답을 해야하며 그렇지 않으면 재전송 됩니다. 하나의 CTS 및 RTS 메시지만을 사용하여 여러 프래그먼트가 전송됩니다.<li>802.11의 fragmentation ↔ 메시지 패싱(Message Passing)<ul><li>802.11에서 RTS와 CTS는 첫 번째 데이터 조각과 첫 번째 ACK에 대해서만 매체를 예약. 첫 번째 조각과 ACK는 두 번째 조각과 ACK에 대한 매체를 예약하고, 이런 식으로 계속됨. 따라서 각 이웃 노드는 조각이나 ACK를 받은 후에도 아직 보내야 할 조각이 하나 더 있다는 것을 알 수 있습니다. 따라서 모든 조각이 전송될 때까지 계속해서 수신 대기해야 함. 다시 말해 에너지 제약이 있는 노드에서는 모든 이웃 노드가 수신 대기하면서 많은 에너지가 낭비될 수 있음<li>802.11에서 송신자가 어떤 조각에 대한 ACK를 받지 못한 경우, 전송을 포기하고 매체를 재경쟁해야 합니다. 그래서 다른 노드가 전송할 기회를 갖게 됩니다. 이로 인해 수신자가 실제로 전체 메시지를 처리하기 위해 전체 메시지가 필요한 경우 오랜 지연이 발생할 수 있습니다. 이와 대조적으로 메시지 패싱(Message Passing)은 전송 시간을 연장하고 현재 조각을 다시 전송합니다. 이로써 경합이 적고 지연 시간이 짧아집니다.<li>센서 네트워크의 경우 노드별 공정성(per-node fairness)이 아닌 응용 프로그램 수준의 공정성(application-level fairness)이 목표</ul></ul><li><strong>Contribution</strong><ul><li>대기 리스닝 감소(주기적인 리스닝 및 슬립은 네트워크의 유휴 청취를 줄이며, 동일한 수면 일정을 가진 노드의 가상 클러스터를 형성하기 위해 동기화를 사용)<li>노드가 이웃이 다른 노드로 전송할 때 슬립 모드로 들어가도록 채널 내 신호화를 사용합니다. 이는 overhearing 문제를 해결<li>RTS 및 CTS 사용으로 충돌 및 동시 수신 방지<li>메시지의 연속적인 프래그먼트 전송으로 에너지 및 시간 절약(모든 프래그먼트를 전송한 후 경쟁을 하지 않음)</ul><li><strong>한계점</strong><ul><li><strong>각 노드의 주기적인 수면으로 인해 지연이 증가. 또한 지연은 각 호프에서 누적</strong><li>S-MAC과 802.11-like 프로토콜을 비교할 때, sleep 지연은 S-MAC에서 더 크지만 에너지 절약도 더 큽니다. 이는 S-MAC에서 노드가 더 많은 시간을 sleep 상태로 보내기 때문입니다. 따라서, S-MAC은 energy efficiency와 latency 사이의 trade-offs를 제공합니다. 더 많은 에너지를 절약하기 위해 sleep 지연을 증가시킬 수 있습니다. 또는, 더 낮은 latency를 위해 sleep 지연을 줄일 수 있습니다.</ul><li><strong>다른 추가 연구</strong><ul><li>latency를 줄이기 위해 adaptive listening을 도입합니다. 노드가 이웃의 RTS 또는 CTS를 듣는 경우, 전송이 끝날 때 잠깐 깨어납니다. 노드가 data path의 다음 hop이라면, 전송이 끝날 때 깨어나면 패킷을 즉시 전달할 수 있으므로 latency가 줄어듭니다.</ul></ul><h2 id="t-mac-timeout-mac">T-MAC (Timeout MAC) <a href="#t-mac-timeout-mac" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li><strong>S-MAC의 설계를 개선하여, 채널이 유휴 상태(idle)인 경우 깨어있는 기간을 단축시킴 (S-MAC에서는 노드들이 데이터를 보내거나 수신하지 않더라도 깨어있는 기간 동안 깨어있게 됨)</strong><li><p>T-MAC은 동기화 단계 이후에 채널을 짧은 시간 동안(TA) 감지하고, 이 기간 동안 데이터를 수신하지 않으면 노드는 다시 수면 상태로 돌아감. 데이터를 수신하는 경우, 노드는 추가적인 데이터가 없거나 깨어있는 기간이 끝날 때까지 깨어있음</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%2016.png" alt="Untitled" data-proofer-ignore></p><li>RTS Operation TMAC<ul><li>Fixed contention interval<ul><li>T-MAC 프로토콜에서 각 노드는 프레임의 시작에서 대기열에 있는 메시지를 버스트로 전송. 부하가 대부분 높고 변하지 않기 때문에 증가하는 경합 간격은 유용하지 않음</ul><li>RTS retries<ul><li>노드는 응답을 받지 못한 경우 RTS를 재전송하여 다시 시도해야 함. 두 번의 재시도 후에도 응답이 없으면 포기하고 잠자기로 들어감</ul><li>Determining TA<ul><li><p>노드는 이웃들이 아직 통신 중일 때 잠자기 상태로 들어가선 안됨. 이후 메시지의 수신자가 될 수 있기 때문. 따라서 TA는 적어도 CTS 패킷의 시작을 수신하기에 충분히 길어야 함</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%2017.png" alt="Untitled" data-proofer-ignore></p></ul></ul><li>한계점<ul><li>S-MAC 프로토콜에 비해 높은 지연을 가질 수 있음<li>Early sleeping problem<ul><li>이웃한 노드가 아직 해당 노드를 위해 메시지를 가지고 있을 때 노드가 sleep 시작. 이로 인해 T-MAC의 throughput이 전통적인 프로토콜이나 S-MAC throughput의 절반 이하로 감소<li><p>Future request-to-send</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%2018.png" alt="Untitled" data-proofer-ignore></p><ul><li>만약 노드가 다른 노드를 위해 설정된 CTS 패킷을 들어 들었다면, 그 노드는 즉시 FRTS 패킷을 보냄. FRTS 패킷에는 블로킹 데이터 통신의 길이가 포함됨(이 정보는 원래 CTS 패킷에 있었음).<li>FRTS 패킷을 수신한 노드는 자신이 미래에 RTS 패킷의 목표가 될 것임을 알고 그 시간까지 깨어 있음. 노드는 FRTS 패킷의 타이밍 정보를 통해 이를 판단<li>FRTS 패킷이 CTS 이후의 데이터 패킷을 방해하지 않도록 하기 위해, 데이터 패킷은 FRTS 패킷의 기간 동안 지연되어야 함. 이 기간 동안 다른 노드가 채널을 사용하지 못하도록 하기 위해 초기 RTS를 보낸 노드는 작은 Data-Send(DS) 패킷을 전송<li>FRTS 패킷은 DS 패킷과 크기가 동일하기 때문에 DS 패킷과 충돌하지만 다음 데이터 패킷과는 충돌하지 않음. DS 패킷은 소실(DS 패킷에는 유용한 정보가 없음)</ul><li><p>full-buffer priority</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%2019.png" alt="Untitled" data-proofer-ignore></p><ul><li>노드의 전송/라우팅 버퍼가 거의 가득 찬 경우, 해당 노드는 자신을 향한 RTS(Request to Send) 패킷을 받으면 일반적인 CTS(Clear to Send) 응답 대신 즉시 다른 노드로 자신의 RTS 패킷을 전송. Early sleeping problem 확률이 작아짐<li>하지만 단방향 통신이 아닌 경우, 충돌 확률이 급격히 증가할 수 있음. 노드는 적어도 두 번의 경합을 실패한 경우에만 사용할 수 있음</ul></ul></ul></ul><h2 id="b-mac">B-MAC <a href="#b-mac" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>B-MAC은 CSMA 기반 기술로, 저전력 수신과 확장된 프리앰블을 활용하여 저전력 통신을 달성. 각 노드는 깨어있는 기간과 수면 기간을 가지며, 각 노드는 독립적인 스케줄을 가질 수 있음<li>노드가 전송하고자 하는 경우 데이터 패킷 앞에 수신자의 수면 기간보다 약간 더 긴 프리앰블을 둠. 활성 상태 동안, 노드는 매체를 샘플링(무선 매체 또는 무선 채널을 주기적으로 감지)하고 프리앰블이 감지되면 데이터를 수신하기 위해 깨어있게 됨. 확장된 프리앰블을 사용함으로써 발신자는 언제든지 프리앰블 도중에 수신자가 깨어나서 프리앰블을 감지하고 데이터를 수신할 것으로 보장받음<li>B-MAC은 트래픽 부하 변화에 적응할 수 있도록 수면 스케줄을 조정. 저자들은 B-MAC이 대부분의 경우에서 처리량, 지연 시간, 에너지 소비 측면에서 기존 프로토콜을 능가한다고 보여줌. <strong>하지만 B-MAC은 overhearing 문제와 긴 프리앰블로 인한 에너지 사용의 문제를 갖음</strong></ul><h2 id="x-mac">X-MAC <a href="#x-mac" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>새로운 low power listening 방식을 제안, 에너지 소비를 더욱 줄이고 지연 시간을 감소시키기 위해 짧은 프리앰블을 사용<ol><li>주소 정보를 내장한 짧은 preamble: X-MAC은 프리앰블에 목표 수신자의 주소 정보를 포함시켜서 비목표 수신자들이 빠르게 수면 상태로 돌아가도록 합니다. 이는 overhearing 문제를 해결하는데 도움이 됩니다. 즉, 비목표 수신자들이 불필요하게 활성화되어 에너지를 소비하는 것을 방지합니다.<li>strobed preamble: X-MAC은 프리앰블들 사이에 간격을 두어 스트로브드 프리앰블을 만듭니다. 이렇게 하면 목표 수신자가 깨어나서 목표 수신자임을 확인하고 바로 일찍 응답함으로써 프리앰블이 전체적으로 끝날 때까지 기다리며 발생하는 시간과 에너지의 낭비를 줄일 수 있습니다. 이러한 짧은 스트로브드 프리앰블 접근 방식은 송신자와 수신자 모두에서 에너지 절약과 호프당 지연 시간 감소를 이룰 수 있습니다.<li>수신자 duty cycle을 동적으로 조정하는 적응 알고리즘: X-MAC은 네트워크에서의 트래픽 부하에 가장 적합하도록 노드들의 수신자 duty cycle을 동적으로 조정하는 적응 알고리즘을 설명합니다. 이로써 데이터 패킷 당 에너지 소비와 지연을 최적화</ol><li>위와 같은 방법을 통해 overhearing 문제를 개선함<ul><li>LPL의 주요한 한계는, 비-목표 수신기들은 프리앰블이 전송되는 동안 매체를 샘플링하고 깨어나 있어야 하며, 마침내 그들이 목표가 아니라는 것을 알게 되는데 확장된 프리앰블이 끝날 때까지 기다려야 한다는 점. 이것을 overhearing 문제라고 하며, 비동기적 기술에서 비효율성과 에너지 낭비의 큰 부분임. 이는 각 송신에 대한 에너지 소모가 수신 범위 내의 수신기 수와 비례함</ul><li><p>Comparison of the timelines between LPL’s extended preamble and X-MAC’s short preamble approach.</p><p><img data-src="/assets/img/2023-07-01-post230701/Untitled%2020.png" alt="Untitled" data-proofer-ignore></p></ul><h2 id="wisemac">WiseMAC <a href="#wisemac" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>WiseMAC은 B-MAC과 유사한 기술을 사용하지만, 송신자는 수신자의 awake period 일정을 학습하고, extended preamble의 길이를 줄이기 위해 전송을 예약합니다.<li>이를 위해 수신자는 데이터 acknowledgment 프레임에 다음 awake period의 시간을 넣습니다. 다음에 송신자가 해당 수신자에게 전송하려는 경우, 송신자는 수신자가 깨어날 때까지 잠시만 preamble을 시작할 수 있습니다. 이는 preamble을 전송할 때 에너지를 절약합니다.<li>또한, preamble이 data frame보다 긴 저 트래픽 부하의 경우, WiseMAC은 extended preamble 대신 data frame을 반복합니다. 수신자는 이 data frame을 처리하고, 노드가 대상 수신자가 아닌 경우 sleep으로 돌아갑니다. 노드가 대상 수신자이면 전송이 끝날 때까지 깨어 있고 acknowledgment을 보냅니다.<li>WiseMAC은 저전력 통신과 관련된 많은 문제를 해결하지만, 노드가 변화하는 트래픽 패턴에 적응할 수 있는 메커니즘을 제공하지 않습니다.</ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre>IEEE802.15.4(WSN)

B-MAC (Berkeley MAC)
X-MAC

S-MAC
T-MAC

CW
BEB/Backoff

IEEE802.11
CSMA/CA CD

X-MAC CA
(Dynamic) Duty Cycle

NS-3 Simulator

6G/7G

WSN vs. LORA vs. LIFI

ml/dl/rl Trend
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/network/'>Network</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/network/" class="post-tag no-text-decoration" >Network</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=(Network)(Paper Review) MAC Protocol - woobni's diary.&url=https://woobni.github.io/posts/post230701/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=(Network)(Paper Review) MAC Protocol - woobni's diary.&u=https://woobni.github.io/posts/post230701/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://woobni.github.io/posts/post230701/&text=(Network)(Paper Review) MAC Protocol - woobni's diary." data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div><script src="https://utteranc.es/client.js" repo="woobni/woobni.github.io" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/post240516/">(kube-prometheus-stack) Prometheus 기반 모니터링 스택 구축</a><li><a href="/posts/post240524/">(kube-prometheus-stack) Prometheus 기반 모니터링 스택 Thanos 연동</a><li><a href="/posts/post240515/">PV, PVC의 동적 프로비저닝을 위한 NFS CSI 드라이버 구성</a><li><a href="/posts/post240402/">자바스크립트 런타임</a><li><a href="/posts/post230927/">도커 엔진</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/codingtest/">CodingTest</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes/">Kubernetes</a> <a class="post-tag" href="/tags/javascript/">Javascript</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/contents-caching/">Contents Caching</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/reinforcement-learning/">Reinforcement Learning</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/post220712/"><div class="card-body"> <em class="timeago small" date="2022-07-12 19:30:00 +0900" >Jul 12, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>(Network) Protocol Data Unit (PDU)</h3><div class="text-muted small"><p> 프로토콜 데이터 단위 데이터 통신에서 상위 계층이 전달한 데이터에 붙이는 제어정보를 뜻한다. 데이터 자체는 동일하지만 각 레이어를 거치면서 헤더 정보가 추가되면서 이름이 달라진다. 사용자는 Data 라고 부르고, TCP는 Segment 라고 부르고, IP는 Packet 이라고 부르고, 데이터링크는 Frame, 컴퓨터 하...</p></div></div></a></div><div class="card"> <a href="/posts/post220901/"><div class="card-body"> <em class="timeago small" date="2022-09-01 13:00:00 +0900" >Sep 1, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>(Network) CIDR(Classless Inter-Domain Routing)</h3><div class="text-muted small"><p> IP Address Class 원래 32비트 IPv4 주소는 호스트가 연결되어있는 특정 네트워크를 가리키는 네트워크 영역과 해당 네트워크 내에서 호스트의 주소를 가리키는 나머지 영역으로 구분되어 있습니다. Network Address:그룹(네트워크를 식별하기 위한) Host Address: 개인(네트워크의 호스...</p></div></div></a></div><div class="card"> <a href="/posts/post240524/"><div class="card-body"> <em class="timeago small" date="2024-05-24 19:00:00 +0900" >May 24</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>(kube-prometheus-stack) Prometheus 기반 모니터링 스택 Thanos 연동</h3><div class="text-muted small"><p> 본 글은 ‘(kube-prometheus-stack) Prometheus 기반 모니터링 스택 구축’ 포스팅 이후 진행됨 Background K8S 클러스터에 구성된 Prometheus 기반 모니터링 스택의 Prometheus HA, 메트릭 장기 저장, global view를 구현하기 위해 Thanos 스택 연동 각 Thanos 컴...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/post230525/" class="btn btn-outline-primary" prompt="Older"><p>(Python)[백준] 친구_1058</p></a> <a href="/posts/post230729/" class="btn btn-outline-primary" prompt="Newer"><p>(Java) 객체 지향 4가지 특징, 5가지 원칙</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/woobni">woobni</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/codingtest/">CodingTest</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes/">Kubernetes</a> <a class="post-tag" href="/tags/javascript/">Javascript</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/contents-caching/">Contents Caching</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/reinforcement-learning/">Reinforcement Learning</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script>
